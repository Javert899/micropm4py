<html>
<head>
<title>MicroPM4Py Documentation</title>
<meta name="description" content="This page contains the documentation of the MicroPM4Py Python process mining library for microcontrollers">
<link rel="icon" href="snake.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="snake.ico" type="image/x-icon"/>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-155149260-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-155149260-1');
</script>
<script style="text/javascript" src="jquery.min.js"></script>
<script style="text/javascript" src="bootstrap.min.js"></script>
<link rel="stylesheet" href="bootstrap.min.css">
</head>
<body>
<div class="jumbotron text-center">
  <h1><img src="snake.png" style="width: 100px"></img>MicroPM4Py</h1>
  <p><b>Process Mining for Microcontrollers in Python</b></p> 
</div>

<div class="container">
  <div class="row">
    <div class="col-4">
      <h5><a href="index.html">Home</a></h5>
	<h5><a href="hardware.html">Hardware</a></h5>
      <h5><a href="installation.html">Installation</a></h5>
      <h5><a href="features.html">Features</a></h5>
	<h5><a href="contributors.html">Contributors</a></h5>
	<h5><a href="documentation.html">Documentation</a></h5>
    </div>
    <div class="col-8">
      <h3>Documentation</h3>
	<p>This page contains the documentation of the MicroPM4Py Python process mining library for microcontrollers / embedded systems. Please use these links to reach the section of interest.
	<ul>
	<li><a href="#xes">Importing/exporting XES files</a></li>
	<li><a href="#csv">Importing/exporting CSV files</a></li>
	<li><a href="#dfg">Working with DFGs</a></li>
	<li><a href="#petri1">Petri Nets - Importing/Exporting/Visualization</a></li>
	<li><a href="#petri2">Petri Nets - Execution semantics</a></li>
	</ul>
	<div id="xes">
	<h5>Importing/exporting XES files</h5>
	<p>All the features of import/export in MicroPM4Py works only with the
	<b>case ID</b> and <b>activity</b> attributes. Other attributes of the
	log are currently simply ignored.</p>
	There are several ways to import a XES file in MicroPM4Py:
	<ul>
	<li>Importing a XES file as a list of cases (assuming one tag per row in the XML file).</li>
	<li>(Standard importer; works always albeit is slower) importing the XES as a list of cases.</li>
	<li>Importing the XES as a DFG object.
	</ul>
	In the following, an example of the format in which the log is stored in memory is reported.
	Within this data structure, no further compression of strings is done (while the DFG object is optimized to minimize the memory footprint).
	Here, a list of tuples is obtained. For each tuple, the first element is the case ID, while the second is the tuple of activities contained in the case (the so-called trace).
	<div style="background-color: black; color: white; width: 100%">
	[('3', ('register request', 'examine casually', 'check ticket', 'decide', 'reinitiate request', 'examine thoroughly', 'check ticket', 'decide', 'pay compensation')), ('2', ('register request', 'check ticket', 'examine casually', 'decide', 'pay compensation')), ('1', ('register request', 'examine thoroughly', 'check ticket', 'decide', 'reject request')), ('6', ('register request', 'examine casually', 'check ticket', 'decide', 'pay compensation')), ('5', ('register request', 'examine casually', 'check ticket', 'decide', 'reinitiate request', 'check ticket', 'examine casually', 'decide', 'reinitiate request', 'examine casually', 'check ticket', 'decide', 'reject request')), ('4', ('register request', 'check ticket', 'examine thoroughly', 'decide', 'reject request'))]
	</div>
	The following code snippet helps to import a XES file into the previously described data structure (here, the faster but non-standard importer is used):
	<div style="background-color: black; color: white; width: 100%">
        from micropm4py.log import xes_import_traces_file<br />
        log = xes_import_traces_file.imp_list_traces_from_file('micro_tests/running-example.xes')<br />
        </div>
	Instead, here the standard importer is used (slower but always works)
	<div style="background-color: black; color: white; width: 100%">
	from micropm4py.log import xes_import_traces_file_standard<br />
	log = xes_import_traces_file_standard.imp_list_traces_from_file('micro_tests/running-example.xes')<br />
	</div>
	To export a log structure into a XES file (only with case ID and activity), the following code can be used:
	<div style="background-color: black; color: white; width: 100%">
	from micropm4py.log import xes_export_traces_file<br />
	xes_export_traces_file.export_traces(log, 'ru.xes')
	</div>
	To import a DFG from the XES, without need to store all the event log, the following code can be used. In the following of the documentation, the description of the DFG structure is reported.
	<div style="background-color: black; color: white; width: 100%">
        from micropm4py.log import xes_import_traces_file_standard<br />
	dfg = xes_import_traces_file_standard.imp_dfg_file('micro_tests/running-example.xes')
	</div>
	</div>
	<br />
	<div id="csv">
	<h5>Importing/exporting CSV files</h5>
	For importing a CSV file (just the case ID and the activity), the following information is needed:
	<ul>
	<li>The separator character (, or ;) that separates the columns of the CSV file</li>
	<li>The name of the column containing the case ID</li>
	<li>The name of the column containing the activity</li>
	</ul>
	The following code snippet helps to import a CSV file into the log data structure. Here, the first argument of the method is the path to the CSV file,
	the second element is the separator, the third element is the case ID column, and the fourth element is the activity column. No support for the quotechar is there.
	<div style="background-color: black; color: white; width: 100%">
	from micropm4py.log import csv_import_traces_file<br />
	log = csv_import_traces_file.import_traces_path('micro_tests/running-example.csv', ',', 'case:concept:name', 'concept:name')
	</div>
	The following code snippet helps to export a log into a CSV. Here, the first argument is the log structure, the second is the (target) file path, the third is the separator, the fourth is the name of the (exported file) case ID column, the fifth is the name of the (exported file) activity column.
	<div style="background-color: black; color: white; width: 100%">
	from micropm4py.log import csv_export_traces_file<br />
	csv_export_traces_file.export_to_path(log, 'ru.csv', ',', 'case:concept:name', 'concept:name')
	</div>
	To import directly the DFG from the CSV, without the need to store the log in-memory (so, significant memory gains are achieved), the following code can be used:
        <div style="background-color: black; color: white; width: 100%">
	from micropm4py.log import csv_import_traces_file<br />
	dfg = csv_import_traces_file.import_dfg_path('micro_tests/running-example.csv', ',', 'case:concept:name', 'concept:name')
	</div>
	</div>
	<br />
	<div id="dfg">
	<h5>Working with DFGs</h5>
	<p>A DFG is an object that is central for many process mining applications (e.g. Alpha Miner, Inductive Miner Directly-Follows, DFG mining techniques ...).</p>
	It can be described as a composite object containing:
	<ul>
	<li>The list of activities of the log</li>
	<li>The start activities of the log</li>
	<li>The end activities of the log</li>
	<li>The tuples of activities directly-following each other in some cases of the log, along with the occurrences of the relationship</li>
	</ul>
	<p>The DFG data strucure in MicroPM4Py is described by the following example:</p>
	<div style="background-color: black; color: white; width: 100%">
	[('>>', 'register request', 'examine casually', 'check ticket', 'decide', 'reinitiate request', 'examine thoroughly', 'pay compensation', '[]', 'reject request'), {0: 6, 1: 6, 2: 6, 3: 9, 4: 9, 5: 3, 6: 3, 7: 3, 8: 6, 9: 3}, (0,), (8,), {(0, 1): 6, (1, 2): 3, (3, 2): 2, (1, 3): 2, (4, 9): 3, (6, 4): 1, (5, 6): 1, (3, 4): 6, (9, 8): 3, (5, 2): 1, (4, 7): 3, (6, 3): 2, (4, 5): 3, (2, 3): 4, (3, 6): 1, (1, 6): 1, (7, 8): 3, (2, 4): 2, (5, 3): 1}]
	</div>
	<p>Here, the first sublist is the tuple of activities in the log, the second dictionary associates the index of the activity (according to the first tuple) to the number of occurrences of the activity,
	the third set is the tuple of start activities of the log, the fourth tuple is the set of end activities of the log; the last dictionary contains the tuples of activities directly-following each other.</p>
	<p>DFGs can be directly imported in MicroPM4Py without the need to 'pass into' the log structure, as seen in the previous sections of the documentation.</p>
	<p>Alternatively, a log structure can be converted to a DFG with the following snippet:</p>
	<div style="background-color: black; color: white; width: 100%">
        from micropm4py.conversion.dfg import traces_to_dfg<br />
	dfg = traces_to_dfg.trs_to_dfg(log)
	</div>
	To produce a visualization of the DFG into the .dot format (Graphviz), the following code snippet can be used. Here, the first element is the (target)
	file path, while the second element is the DFG object:
	<div style="background-color: black; color: white; width: 100%">
	from micropm4py.visualization.dfg_saver import save_dot<br />
	save_dot('graph.dot', dfg)
	</div>
	The DOT file can be then rendered using the Graphviz tools. For small graphs, to render the DOT into a PNG, the following shell command can be used
	<div style="background-color: gray; color: white; width: 100%">
	dot -Tpng graph.dot > graph.png
	</div>
	For bigger graphs, the following shell command can be used:
	<div style="background-color: gray; color: white; width: 100%">
	neato -Tpng graph.dot > graph.png
	</div>
	</div>
	<br />
	<div id="petri1">
	<h5>Petri Nets - Importing/Exporting/Visualization</h5>
	<p>Petri Nets are a widely used class of models in the process mining world. In MicroPM4Py, we offer support for importing/exporting/visualizing <b>accepting</b> Petri nets (that are Petri nets along with an initial and a final marking).</p>
	<p>A limitation of the implementation is the lack of compatibility for invisible transitions. Duplicate visible transitions are instead supported.</p>
	<p>Another limitation of the import/export from PNML is the support for arc weights equal to 1.</p>
	<p>The data structure hosting the Petri nets in MicroPM4Py is reported in the following example. The first tuple contains the names of the places (the example contains 3 places, the source place, the sink place and a place named p1). The second tuple contains the transitions. Each transition is a (sub)tuple where the first element is the label of the transition, the second element is the preset of the transition (the key is the index of the place in the first sublist, the value is the arc weight), the third element is the postset of the transition (described in an analogous way as the preset).</p>
	<div style="background-color: black; color: white; width: 100%">
	[("source", "p1", "sink"), (("A", {0: 1}, {1: 1}), ("B", {1: 1}, {2: 1}))]
	</div>
	<p>The structure of the initial/final marking is a dictionary (which structure is identical to the one of the preset/postset of a transition). As example:</p>
        <div style="background-color: black; color: white; width: 100%">
	{0: 1}
	</div>
	The following code snippet imports a Petri net from a PNML file, along with its initial and final marking:
        <div style="background-color: black; color: white; width: 100%">
	from micropm4py.petrinet import petrinet_import_file<br />
	net, im, fm = petrinet_import_file.imp_file('micro_tests/running-example.pnml')
	</div>
	The following code snippet exports a Petri net into a PNML file, along with its initial and final marking:
	<div style="background-color: black; color: white; width: 100%">
	from micropm4py.petrinet import petrinet_export_file<br />
	petrinet_export_file.export(net, im, fm, "target.pnml")
	</div>
        To produce a visualization of the Petri net into the .dot format (Graphviz), the following code snippet can be used. Here, the first element is the (target)
        file path, while the second element is the Petri net object (visualized without specification of the initial and final marking):
        <div style="background-color: black; color: white; width: 100%">
        from micropm4py.visualization.petri_saver import save_dot<br />
        save_dot('graph.dot', net)
        </div>
	The DOT file can be then rendered using the Graphviz tools. For small graphs, to render the DOT into a PNG, the following shell command can be used
        <div style="background-color: gray; color: white; width: 100%">
        dot -Tpng graph.dot > graph.png
        </div>
        For bigger graphs, the following shell command can be used:
        <div style="background-color: gray; color: white; width: 100%">
        neato -Tpng graph.dot > graph.png
        </div>
	</div>
	<br />
	<div id="petri2">
	<h5>Petri Nets - Execution semantics</h5>
	<p>Petri nets are a widely used formalism in process mining, and their importing/exporting/visualization has been described in the previous section.
	A <b>marking</b> is a set of tokens distributed among the places of the Petri net.</p>
	<p>The execution semantics of a Petri net is clear: when a transition is executed, a number of tokens (the preset of the transition) is consumed from the current marking, and a number of tokens (the postset of the transition) is inserted into the marking.</p>
	<p>In an accepting Petri net, the initial state of any execution is the initial marking. Ideally, the expectation is that every process execution finishes in the final marking.</p>
	<p>Let's see an example. Before everything, import the execution semantics of the Petri net, and actually import a Petri net, for example the running-example one.
	<div style="background-color: black; color: white; width: 100%">
	from micropm4py.petrinet import petrinet_exec<br />	
	from micropm4py.petrinet import petrinet_import_file<br />
	net, im, fm = petrinet_import_file.imp_file('../micro_tests/running-example.pnml')
	</div>
	This Petri net can be represented (using MicroPM4Py) as follows:
	<div class="text-center">
	<img src="ru.png" style="width: 350px"></img>
	</div>
	<p>The initial activity, as prescribed by the Petri net, is always register request. Then, check ticket is executed concurrently to one between examine casually and examine throughly.
	Then, a decision occurs (decide) on the outcome of the ticket. A reinitiation of the request can happen; if not, one between pay compensation and reject request is executed.</p>
	<p>To execute the same Petri net several times, since the execution acts on the marking, we need to copy the initial marking when we start the execution.
	This can be done with the following code snippet:</p>
        <div style="background-color: black; color: white; width: 100%">
	from micropm4py.util import copy<br />
	m = copy.copy(im)
	</div>
	The Petri net, initial marking and final marking structures, as imported in MicroPM4Py from the PNML file, are:
	<div style="background-color: black; color: white; width: 100%">
	[('start', '({'register request', 'reinitiate request'}, {'check ticket'})', '({'examine casually', 'examine thoroughly'}, {'decide'})', 'end', '({'decide'}, {'reinitiate request', 'pay compensation', 'reject request'})', '({'check ticket'}, {'decide'})', '({'register request', 'reinitiate request'}, {'examine casually', 'examine thoroughly'})'), (('decide', {2: 1, 5: 1}, {4: 1}), ('examine casually', {6: 1}, {2: 1}), ('examine thoroughly', {6: 1}, {2: 1}), ('register request', {0: 1}, {1: 1, 6: 1}), ('check ticket', {1: 1}, {5: 1}), ('reinitiate request', {4: 1}, {1: 1, 6: 1}), ('pay compensation', {4: 1}, {3: 1}), ('reject request', {4: 1}, {3: 1}))]<br />
	{0: 1}<br />
	{3: 1}
	</div>
	As in the process model, we execute the activity register request. We expect to enable both the check ticket activity and one between examine casually/examine throughly. This is exactly what happens:
	<div style="background-color: black; color: white; width: 100%">
	{1: 1, 6: 1}
	</div>
	Then, let's try to execute the following list of activities: examine casually, check ticket, decide, pay compensation. That should lead to the final marking of the process model.
        <div style="background-color: black; color: white; width: 100%">
	petrinet_exec.exec(net, m, "examine casually")<br />
    	petrinet_exec.exec(net, m, "check ticket")<br />
    	petrinet_exec.exec(net, m, "decide")<br />
    	petrinet_exec.exec(net, m, "pay compensation")
	</div>
	This is exactly what happens:
	<div style="background-color: black; color: white; width: 100%">
	{3: 1}
	</div>
	<p><b>Token-based Replay</b>: instead of executing the activity one-by-one, in MicroPM4Py there is the possibility to execute through token-based
	replay an entire trace, just to check whether it fits or not (so, returning a boolean value). Please reminder that there is support only for visible
	transitions, and the replay just tells if the trace is fit or not, no other information (missing/remaining tokens, fitness ...).</p>
	<p>Let's try to execute token-based replay on a fit trace. The True value is printed correctly:</p>
	<div style="background-color: black; color: white; width: 100%">
	m = copy.copy(im)<br />
	res = petrinet_exec.ex_trace(net, m, fm, ['register request', 'examine casually', 'check ticket', 'decide', 'pay compensation'])<br />
    	print(res)
	</div>
	A token-based replay on an unfit trace prints False as expected (here, the unfitness is the lack of execution of the activity check ticket).
        <div style="background-color: black; color: white; width: 100%">
        m = copy.copy(im)<br />
        res = petrinet_exec.ex_trace(net, m, fm, ['register request', 'examine casually', 'decide', 'pay compensation'])<br />
        print(res)
        </div>
	A token-based replay on a trace that is fitting but without reaching (still) the final marking prints False (since the FM is not reached):
        <div style="background-color: black; color: white; width: 100%">
        m = copy.copy(im)<br />
        res = petrinet_exec.ex_trace(net, m, fm, ['register request', 'examine casually', 'check ticket', 'decide'])<br />
        print(res)
        </div>

	</div>
    </div>
  </div>
</div>
</body>
</html>
